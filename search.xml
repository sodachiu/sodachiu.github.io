<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android: 内部存储与外部存储]]></title>
    <url>%2F2018%2F12%2F10%2FAndroid-%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E4%B8%8E%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[在说这两个概念以前，我们需要弄懂三个名词的区别：内存、内部存储、外部存储。 内存(RAM)： Random Access Memory, 也叫主存。是与CPU直接交换数据的内部存储器。它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质 。摘自 维基百科 内部存储(ROM)： Internal Storage, 注意内部存储不是内存，如果将文件存在内部存储中，那么只能被自己的程序访问到。且一个程序所创建的文件都在和应用包名相同的目录下。 参考自 泡在网上的日子 外部存储(ROM)： External Storage, 概念上有点复杂，可以酱紫区别：将手机连上电脑，能被电脑识别，就是外部存储。参考自 泡在网上的日子 接下来我们看一下安卓内部文件结构，这是机顶盒的文档结构，直接进串口看的。安卓机的话，可以看看 参考链接 中查看文档列表的方法。 标红的三个部分为我们需要关注的文件夹。接下来就进入正题。 一. 内部存储 data 目录为 内部存储 的文件夹，里面一般有两个文件夹需要我们注意： 如图所示，我们需要关注 app 和 data 两个文件夹。 app: app 文件夹中存储的是 .apk 文件，是所有我们安装的应用（不包括系统应用）。 data： data 中存储的是所有程序的包名，每个包中都会有如下几个文件夹： data/data/包名/files： 存储普通文件 data/data/包名/databases: 存储数据库文件 data/data/包名/shared_prefs: 存储本地化持久数据 data/data/包名/cache: 存储缓存 data/data/包名/code_cache: 存储由运行时应用程序生成的编译或优化的代码 内部存储的特点：始终可用 二. 外部存储外部存储一般分为 扩展卡内存 和 SD卡 ， 一般来说，mnt (或 storage ) 为外部存储的文件夹，外部存储下一般会有 sdcard 文件夹，这个是 SD卡 的路径。而扩展卡内存，一般为 /mnt/sda/sda1 这类格式。 SD卡(mnt/sdcard 或 storage/sdcard) 九大公有目录，目录中的所有文件均可以被其它程序读取 DCIM(Digital Camera Images)，存储 相机 图片、视频文件 Pictures：存储用户非相机拍摄的可用图片文件 Download：存储用户下载文件的标准目录 Movies：存储可用电影文件 Alarms：存储闹钟音频文件 Notifications：存储通知列表中的音频文件 Ringtones：存储铃声列表中的音频文件 Podcasts：存储播客列表中的音频文件 Music：存储其它音频文件(音乐等…) 私有目录 Android/data 即为私有目录。data 下放着一系列包名组成的文件，与内部存储的 data/data 有点像。每个包名代表对应应用程序的私有目录。把文件放在这里，会减轻内部存储的压力，但是会将数据暴露给用户和其它程序。 扩展卡内存 扩展卡内存 即用户插入的外置 SD卡，没有直接的方法可以获取到扩展卡的路径。获取扩展卡内存的路径可以参考 这里 外部存储的特点： 并非一直可用、全局可读 三. 总结内 / 外存储目录 内部存储目录： /data 外部存储目录： 内置 SD 卡：/mnt/sdcard 或者 /storage/sdcard 扩展 SD 卡： /mnt/sda/ /mnt/sdb 或 /storage/sda /storage/sdb 四. 操作存储空间Google 官方建议 app 的数据应该存储在外部存储的私有目录 /mnt/sdcard/Android/data/ 或 /storage/sdcard/Android/data 下。这样当用户卸载 app 时，会将相关的数据一并删除。 我们可以将文件目录按 是否拥有包名 来进行分类： 拥有包名的路径 &lt;tr&gt; &lt;td rowspan=&quot;5&quot; align=&quot;center&quot;&gt;&lt;b&gt;内部存储&lt;br&gt; /data/data/包名/&lt;/b&gt;&lt;/td&gt; &lt;td&gt;files&lt;/td&gt; &lt;td&gt;context.getFilesDir()&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;cache&lt;/td&gt; &lt;td&gt;context.getCacheDir()&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;shared_prefs&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;code_cache&lt;/td&gt; &lt;td&gt;context.getCodeCacheDir() (API level 21)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;databases&lt;/td&gt; &lt;td&gt;context.getDataDir() (API level 24)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;b&gt;外部存储(mnt 或 storage)&lt;br&gt; /mnt/sdcard/ 或 /storage/sdcard/&lt;/b&gt;&lt;/td&gt; &lt;td&gt;Android/data/包名/files&lt;/td&gt; &lt;td&gt;context.getExternalFiles(&quot;文件夹名&quot;)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Android/data/包名/cache&lt;/td&gt; &lt;td&gt;context.getExternalCacheDir()&lt;/td&gt; &lt;/tr&gt; 可以看到，所有拥有包名路径的基本都可以使用 context 来获取到对应文件 下面我们用代码来看一下 12345678910File internalFiles = mContext.getFilesDir();File internalCache = mContext.getCacheDir(); Log.i(TAG, "onCreate: internalFiles----" + internalFiles.toString());Log.i(TAG, "onCreate: internalCache----" + internalCache.toString()); File externalCache = mContext.getExternalCacheDir();File externalMusic = mContext.getExternalFilesDir(Environment.DIRECTORY_MUSIC);Log.i(TAG, "onCreate: externalCache----" + externalCache);Log.i(TAG, "onCreate: externalMusic----" + externalMusic); 打印结果 不拥有包名的路径 可以使用 Environment 来获取到对应路径。Environment 有以下方法获取到指定目录： 1234567public static File getDataDirectory();public static File getExternalStorageDirectory();public static File getDownloadCacheDirectory();public static File getRootDirectory();// 获取九大公有目录 // 例：File music = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC); public static File Environment.getExternalStoragePublicDirectory(String type); 下面我们来看一下使用上述方法后的打印结果（具体代码就不贴了） 五. 参考文档 Android内、外存储 易混淆点剖析 Android存储路径你了解多少？ 彻底理解android中的内部存储与外部存储 数据存储-文件存储 android中的文件操作详解以及内部存储和外部存储 六. 最后整篇文章基于 Android API 19。对于 Android 6.0 后的多用户特性，内部存储通过同样的方法，会拿到类似于 /data/user/0/包名/xxx 之类的路径，这个在以后的文章中再做说明（主要是现在还没有了解到啦~）。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 关于 DialogFragment 的一些总结]]></title>
    <url>%2F2018%2F12%2F10%2FAndroid-%E5%85%B3%E4%BA%8E-DialogFragment-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一. 如何使用 DialogFragment二. DialogFragment 一些常见的样式问题 设置背景透明 参考文档 对话框内部背景透明，在 onCreateView 中加入如下代码： 12// 也可以自定义背景图案getDialog().getWindow().setBackgroundDrawable(newColorDrawable(Color.TRANSPARENT)); 对话框外部背景透明，在 onStart 中加入如下代码： 1234Window window = getDialog().getWindow();WindowManager.LayoutParams windowParams = window.getAttributes();windowParams.dimAmount = 0.0f;window.setAttributes(windowParams) 自定义 DialogFragment 宽度 参考文档 使对话框充满屏幕宽度，在 onCreate 方法中加入如下代码： 1 占用屏幕宽度一定比例，在 onStart 方法中加入如下代码： 1234567 Dialog dialog = getDialog(); if (dialog != null) &#123; DisplayMetrics dm = new DisplayMetrics(); getActivity().getWindowManager().getDefaultDisplay().getMetrics(dm); mDialog.getWindow().setLayout((int) (dm.widthPixels * 0.55) , ViewGroup.LayoutParams.WRAP_CONTENT);&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 利用反射机制挂载/卸载SD卡以及获取外部存储路径]]></title>
    <url>%2F2018%2F12%2F07%2FAndroid-%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%8C%82%E8%BD%BD-%E5%8D%B8%E8%BD%BDSD%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[一. 卸载 SD 卡参考链接 123456789101112public static void unmountVolume(String path) &#123; try &#123; Method method = Class.forName("android.os.ServiceManager") .getMethod("getService", String.class); IBinder binder = (IBinder) method.invoke(null, "mount"); IMountService service = IMountService.Stub.asInterface(binder); service.unmountVolume(path, true, true); &#125; catch (Exception e) &#123; Log.i(TAG, "unmountVolume: 卸载设备出错----" + e.toString()); &#125; &#125; 二. 加载 SD 卡参考链接 123456789101112public static void mountVolume(String path) &#123; try &#123; Method method = Class.forName("android.os.ServiceManager") .getMethod("getService", String.class); IBinder binder = (IBinder) method.invoke(null, "mount"); IMountService service = IMountService.Stub.asInterface(binder); service.mountVolume(path, true, true); &#125; catch (Exception e) &#123; Log.i(TAG, "unmountVolume: 挂载设备出错----" + e.toString()); &#125; &#125; 三. 获取外置存储设备的路径参考链接 1234567891011121314151617181920212223public static String[] getVolumePaths(Context context) &#123; String paths[] = null; StorageManager storageManager = (StorageManager) context .getSystemService(Context.STORAGE_SERVICE); try &#123; Class&lt;?&gt;[] paramClasses = &#123;&#125;; Method getVolumePathsMethod = StorageManager.class .getMethod("getVolumePaths", paramClasses); getVolumePathsMethod.setAccessible(true); Object[] params = &#123;&#125;; paths = (String[]) getVolumePathsMethod.invoke(storageManager, params); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; return paths;&#125; 四. 反射简介 什么是反射反射阔以通过非常规手段直接获取并操作方法、字段等所有类的成员。 如何使用反射这里简单介绍一下如何使用反射。仅能用于理解上面部分代码。如需全面深刻的理解，建议结合 这篇文章 并且动手实践以加深印象。 使用反射的必要条件，即反射的入口 获取需要操作类的 Class 对象，有三种方式： 1) class.class 2) class.instance.getClass() 3) Class.forName() 如，上面的卸载 &amp; 挂载 SD 卡部分的代码Class.forName(&quot;android.os.ServiceManager&quot;) 即使用的方法 3；而获取外部存储设备的路径中 StorageManager.class 即使用的方法 1；通过类的实例获取 Class 的对象的话，就需要使用 getClass() 方法了。 获取指定的方法 当我们获取到类的Class 对象后，就能通过此对象来操作类的成员，这里只介绍如何通过Class 对象来获取对象的方法。 1234Class&lt;?&gt; smClass = Class.forName("android.os.ServiceManager");// 参数 1：需要指定获取方法的名的字符串,这里需要获取 getService(), 就传 Method getService = smClass.getMeDeclaredMethod("getService", String.class); getService.invoke(smClass.newInstance(), ) Class类提供了以下 4 个函数来获取方法： 123456789public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException public Method[] getDeclaredMethods() throws SecurityExceptionpublic Method[] getMethods() throws SecurityException 根据方法名就能明白这些方法的用途。下面来讲一下 getDeclaredMethod() 与 getMethod() 的共同点与差别。 共同点： 需要传入 方法名 以及 参数类型 来获取指定方法。方法的名字不难理解，你需要告诉程序，你想要哪一个方法。而参数类型，是为了避免方法重载，程序无法获知你需要的具体方法。方法名 以及 参数类型 就像坐标，帮程序准确定位。 区别： getMethod 只能获取到使用 public 修饰符修饰的方法，且能获取到继承父类中的方法；而 getDeclaredMethod 阔以获取到所有该类中的方法，但无法获取父类中的任何办法。 下面我们使用 getDeclaredMethods 和 getMethods 来验证一下区别： Father: 1234567891011121314public class Father &#123; public Father() &#123; &#125; public void fatherMethod1() &#123; System.out.println("father's public method"); &#125; private void fatherMethod2() &#123; System.out.println("father's private method"); &#125;&#125; Son: 12345678910111213public class Son extends Father &#123; public Son() &#123; &#125; public void sonMethod1() &#123; System.out.println("son's public method"); &#125; private void sonMethod2() &#123; System.out.println("son's private method"); &#125; &#125; ReflectTest: 1234567891011121314151617181920212223public class ReflectTest &#123; public static void main(String[] args) &#123; try &#123; Class&lt;?&gt; sonClass = Class.forName("Son"); Method[] methods = sonClass.getMethods(); Method[] declaredMethods = sonClass.getDeclaredMethods(); for (Method method : methods) &#123; System.out.println("getMethods----" + method); &#125; for (Method method : declaredMethods) &#123; System.out.println("getDeclaredMethods----" + method); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印结果： 可以看到， getMethods() 成功获取到使用 public 修饰符修饰的方法，包括 Object 中的方法。而getDeclaredMethods() 只获取到了Son类中的所有方法，无法获得继承的方法。 调用指定方法 调用方法使用: 1public Object invoke(Object obj, Object... args) 参数1：指定类的实例，可以通过 Class.newInstance() 获得。通过反射获取类的实例有两种方法，我们这里使用最 简单的，也是不推荐用的。需要了解更多可以 点击这里看看 参数2：调用该方法传入的值。（这里应该好理解吧？虽然我说得很抽象…） 代码部分: 12345678910111213141516171819202122public class ReflectTest &#123; public static void main(String[] args) &#123; try &#123; Class&lt;?&gt; sonClass = Class.forName("Son"); Method method1 = sonClass.getDeclaredMethod("sonMethod1", null); method1.invoke(sonClass.newInstance(), null); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 使用到的类都是上面用过的，就不再贴代码了。 可以看到，这里 参数2 我传入的值为 null, 因为该方法不需要参数。 打印结果： 至此好像就把最上边设计到的两三行代码讲完了… 五. 总结 获得 Class 对象有三种方法。 获得指定方法有两种方式，传入的参数为 方法名 以及 参数类型 ；获取方法集有两种方法。 调用方法使用 invoke 传入的参数为 类的实例 以及 方法值 ，如果该方法为静态，那么 类的实例 可以为 null]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 关于存储设备状态改变的静态广播无法接收的问题]]></title>
    <url>%2F2018%2F12%2F06%2FAndroid-%E5%85%B3%E4%BA%8E%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98%E7%9A%84%E9%9D%99%E6%80%81%E5%B9%BF%E6%92%AD%E6%97%A0%E6%B3%95%E6%8E%A5%E6%94%B6%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一. 问题描述：最近在重构存储设备功能模块，想要将原本的动态广播转换为静态广播，这样不管在哪个地方，存储设备状态改变，我都能收到提示。于是我尝试了以下代码： 123456789&lt;receiver android:name=".MyFileReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter android:priority="100"&gt; &lt;action android:name="android.intent.action.MEDIA_MOUNTED" /&gt; &lt;action android:name="android.intent.action.MEDIA_UNMOUNTED" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 但是如论如何，都接收不到该广播。 起初以为是自己的java 文件有毛病，但是手动发送一个广播，又能成功接收到。 所以具体是什么原因呢？ 首先我按照 “静态广播无法接收” 的关键词 google 了一下，查到的全是静态广播如何写这样的文章，我…. 二. 解决办法过了几天，突发奇想，按照“INTENT.ACTION_MEDIA_MOUNTED” 这个关键词直接 google，找了一圈，发现 一篇文章 里有解决办法，如下: 1234567891011&lt;receiver android:name=".MyFileReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter android:priority="100"&gt; &lt;action android:name="android.intent.action.MEDIA_MOUNTED" /&gt; &lt;action android:name="android.intent.action.MEDIA_UNMOUNTED" /&gt; // 需要添加下面这一行 &lt;data android:scheme="file"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 所以为什么要添加这一行呢，参考链接里也贴了 详解的链接 ，接下来，我就再复习一遍吧。 三. 关于 Andoroid 事件过滤策略 Intent 的分类：显式和隐式 一个 Intent 包含的信息 图片取自 Intent详解 该文章有对 Intent 进行较为详细的解释，需要的战友可以进去看看。由图可以看到，显式 Intent 与隐式 Intent 最大的区别，是 ComponentName 是否为空。 2. 事件过滤策略与 IntentFilter原链接 的比喻挺适合理解。我就用自己的话再复述一遍吧：将系统广播的分发比喻为信件的派发。当信件上有收件人的详细地址时，邮递员可以直接通过地址找到你，并将信件放到你的手上。那如果，信件上没有详细地址，只有收件人的特征—— 男，30岁，码农。这样的信件邮递员该如何处理呢？邮递员惊喜地发现，负责信件派发区域内的所有房门上都有住户的特征介绍，比如：女，20岁，学生； 女，35岁，家庭主妇… 如此一来，只要对应上 所有 特征，就把信件交付给相应地住户就 OK 了。 当然这是不恰当地比喻，因为信件只有一封，只能给到一个人。但是系统可以将事件分发给所有符合条件的程序。 这个比喻里，有详细地址的信件，就相当于 Intent.getComponent != null 系统可以通过ComponentName 直接找到接收此事件的组件。而没有指定Intent.Component 的事件，就只能借助其它特征来决定该给哪些程序发广播了，这些特征就是Action 、Data 、Category 当程序给出的所有接收特征与系统广播的这些特征一一对应，那么就能接收到相应的广播啦。 那么我们就来研究下，在 SD 卡发生插拔事件时，系统发出的广播都携带了哪些特征叭！ 动态注册广播： 12345IntentFilter filter = new IntentFilter();filter.addAction(Intent.ACTION_MEDIA_MOUNTED);filter.addAction(Intent.ACTION_MEDIA_UNMOUNTED);filter.addDataScheme("file"); // 必需，否则无法接收到事件mContext.registerReceiver(myStorageReceiver, filter); 打印信息 123456789101112131415161718192021222324252627282930313233343536private BroadcastReceiver myStorageReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; ComponentName componentName = intent.getComponent(); Set&lt;String&gt; categories = intent.getCategories(); Uri data = intent.getData(); String action = intent.getAction(); if (componentName != null) &#123; Log.i(TAG, "onReceive: componentName----" + componentName.toString()); &#125; else &#123; Log.i(TAG, "onReceive: componentName----null"); &#125; if (categories != null) &#123; for (String item : categories) &#123; Log.i(TAG, "onReceive: category----" + item); &#125; &#125; else &#123; Log.i(TAG, "onReceive: categories----null"); &#125; if (data != null) &#123; Log.i(TAG, "onReceive: data----" + data); &#125; else &#123; Log.i(TAG, "onReceive: data----null"); &#125; if (action != null) &#123; Log.i(TAG, "onReceive: action----" + action); &#125; else &#123; Log.i(TAG, "onReceive: action----null"); &#125; &#125; &#125;; 打印结果 可以看到，componentName 为 空，为隐式事件。 由图可以看到，IntentFilter 可以添加如上特征进行事件过滤，必须全部匹配才能收到事件广播。 3. Data 匹配规则 Data 由 Uri 来描述，而Uri由三部分组成： ==scheme://host:port/path== | 模式://端口:主机号/路径 从打印结果可以看到，SD 挂载事件，data: scheme == &quot;file&quot; 现在我们需要了解一个规则，即对于Uri，只比较filter 中声明的部分，如果匹配到声明的部分，即认为匹配成功。 我们代码中只声明了scheme 部分，并且与Uri 成功匹配，所以匹配成功。 Uri 的具体匹配规则如下： 如果data 的Uri与dataType 均为空，那么filter中也需要全部为空才能匹配成功 如果data的Uri为空，dataType不为空，那么filter中的Uri必须为空，且dataType匹配成功，才能匹配成功 如果data的Uri 不为空，dataType为空，那么filter中的Uri必须匹配成功，且dataType为空，才能匹配成功 如果data 的Uri与dataType 均不为空，那么filter中必须定义两者并且都匹配成功，才能匹配成功 一句话总结，即IntentFilter必须与Intent携带信息全部匹配成功，才能接收事件。 四. 最后还是看看 原链接 吧，讲得真的很好了。小菜鸡的语言组织能力还是太差了，今后继续加油。 留下疑问：既然data的Uri认为部分匹配成功，即认为匹配成功。那么我filter中不添加scheme，只添加path 匹配成功也收不到广播的问题在哪？]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: fragment生命周期与执行hide、show后经历的生命周期]]></title>
    <url>%2F2018%2F11%2F16%2FAndroid-fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E6%89%A7%E8%A1%8Chide%E3%80%81show%E5%90%8E%E7%BB%8F%E5%8E%86%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[参考文档： Fragment生命周期与Fragment执行hide、show后的生命周期探讨]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 获取当前显示的fragment对象]]></title>
    <url>%2F2018%2F11%2F16%2FAndroid-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%98%BE%E7%A4%BA%E7%9A%84fragment%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[参考文档： 获取当前显示的fragment对象 Android 通过Activity获取当前显示的Fragment]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux: chmod命令]]></title>
    <url>%2F2018%2F11%2F16%2FLinux-chmod%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[参考文档： linux命令之chmod用法]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: sp 还是dp？]]></title>
    <url>%2F2018%2F11%2F16%2FAndroid-sp-%E8%BF%98%E6%98%AFdp%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[参考文档： Android下设置文字大小用sp还是dp]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: getSupportFragmentManager & gerFragmentManager]]></title>
    <url>%2F2018%2F11%2F16%2FAndroid-getSupportFragmentManager-gerFragmentManager%2F</url>
    <content type="text"><![CDATA[参考文档： 在activity中无法使用getFragmentManager()]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android：神奇的属性篇]]></title>
    <url>%2F2018%2F11%2F16%2FAndroid%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B1%9E%E6%80%A7%E7%AF%87%2F</url>
    <content type="text"><![CDATA[1. ListView 篇android:listselector ​ 该属性可以自定义选中属性,如：android:listselector=&quot;@drawable/xx_selector&quot; android:divider ​ 该属性可以自定义item分割线 的样式，如：android:divider=&quot;@null&quot; android:dividerHeight ​ 该属性可以自定义item之间的垂直距离，如：android:dividerHeight=&quot;16dp&quot;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 获取当前焦点位置]]></title>
    <url>%2F2018%2F11%2F16%2FAndroid-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%84%A6%E7%82%B9%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[参考文档： Android获取当前焦点的位置，查找焦点的位置]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重温一遍做项目的流程]]></title>
    <url>%2F2018%2F11%2F14%2F%E9%87%8D%E6%B8%A9%E4%B8%80%E9%81%8D%E5%81%9A%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[将 jar 包放进 libs 文件夹，然后File--&gt;Project Structure--&gt;modules--&gt;Dependencies--&gt;右上角“+”号， jar Dependency， 选中对应文件，点击ok--&gt;scope选择compile only，点击ok 在项目的build.gradle中找到 allprojects ，在里面加入以下代码： 123456gradle.projectsEvaluated &#123; tasks.withType(JavaCompile)&#123; options.compilerArgs.add( '-Xbootclasspath/p:模块名/libs/jar包名') &#125; &#125; 1234567allprojects &#123;====复制代码到这个位置==== repositories &#123; google() jcenter() &#125;&#125; 如果在代码中出现报红，可在module下找到xxx.iml文件，添加以下代码： 1&lt;orderEntry type="library" exported="" name="jar包名" level="project" /&gt; 不过我还是无法解决报红问题啦，但是不影响代码跑起来就行 申请系统权限：在AndroidMainfest.xml 中首层标签中添加以下代码： 1android:sharedUserId="android.uid.system" 然后在module 的 build.gradle 内添加以下代码： 123456789101112131415signingConfigs &#123; release &#123; storeFile file("F:/signed/test.jks") storePassword '123456' keyAlias 'ch' keyPassword '123456' &#125; debug &#123; storeFile file("F:/signed/test.jks") storePassword '123456' keyAlias 'ch' keyPassword '123456' &#125;&#125; 在 defaultConfig后面添加就行 1234567defaultConfig &#123; ... &#125; ====这里添加==== buildTypes &#123; ... &#125; 在Build 下选择 Generate Signed APK... 点击Create New， 新建一个密钥，Key store path 需要与上面配置的路径一样，Password 与上面的storePassword相同，alias与上面配置的keyAlias相同，Password 与上面配置的keyPassword 相同，其余任性填，确认后，点击面板的next ，找到Signature Version 勾选上 V2(Full APK Signature) 点击确定。然后就能直接在AS上往机顶盒里推APK 了]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>项目流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络测试步骤]]></title>
    <url>%2F2018%2F11%2F13%2F%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[进入页面查看是否根据当前连接的网络进行相应的显示（已连接位置对否，焦点是否正确 进入静态IP 点击取消，查看当前网络状态是否改变，如果改变，则有bug 输入错误的IP，看能否正确判断 输入错误的netmask 输入错误的gateway 输入错误的dns1 输出错误的dns2 输入gateway与ip不在同一个网段 输入正确的格式，尝试连接静态IP，看能够连接上网络 如果用户在已经连接静态IP的情况下，没有修改任何信息，再次点击“确定”，提示用户没有修改任何信息 进入pppoe 不输入用户名及密码，查看提示 输入用户名密码，查看提示 退出该界面，查看上一层网络连接状态是否改变 如果用户在pppoe已经连接上的情况，不改变用户名和密码再次点击“确定”按钮，提示已经连接 断开网线，查看提示 点击连接pppoe，dhcp，静态ip，查看是否提示网线没有插上 插上网线，查看提示是否为网线已插入，是否会更新网络状态 插上网线，但不联网，查看提示状态已经网络更新状态 在dhcp连接的情况下，点击连接dhcp，看提示 在dhcp没有链接的情况下，点击连接dhcp，看提示 在有网线，但没网的情况下，把所有以上逻辑测一遍，看有什么问题]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: style复用共有属性]]></title>
    <url>%2F2018%2F11%2F12%2FAndroid-style%E5%A4%8D%E7%94%A8%E5%85%B1%E6%9C%89%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[参考文档： Android Style 继承]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java: 正则表达式]]></title>
    <url>%2F2018%2F11%2F08%2FJava-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考文档： Java 正则表达式 【.】 通配符，匹配任一个字符 【\s+】 匹配多个数字 【\d+】 匹配一个或多个数字 【^】 定义以什么开始 【$】 定义以什么结尾 【?】 0次或一次匹配 【+】 一次或多次匹配 【{n}】正好匹配n次 【{n,}】至少匹配n次 【{n, m}】 匹配n-m次 【x|y】 匹配x或y 【[xyz]】 匹配包括的任意字符 【^[xyz]】 匹配不包括的任意字符，==反向字符集== 【[a-z]】 匹配a-z的字符范围内的任意字符 \ 转义符 捕获组（）在小括号里创建，把多个字符当成单独单元进行处理 例如: (dog) 小知识在其他语言中，\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。 在 Java 中，\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。 所以，在其他的语言中（如Perl），一个反斜杠 \ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\ 代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\\\。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java: 判断IP是否合法]]></title>
    <url>%2F2018%2F11%2F08%2FJava-%E5%88%A4%E6%96%ADIP%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95%2F</url>
    <content type="text"><![CDATA[参考文档： 笔试1–判断一个IP地址是否合法 【面试题】算法题：判断一个IP是否是合法 IP地址和子网划分学习笔记之《子网掩码详解》 IPv4中IP地址分类]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络: 初始DNS服务器哪里来的]]></title>
    <url>%2F2018%2F11%2F05%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%88%9D%E5%A7%8BDNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%AA%E9%87%8C%E6%9D%A5%E7%9A%84%2F</url>
    <content type="text"><![CDATA[参考文档： 初始DNS服务器地址是哪里来的？]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 数据库操作 Cursor]]></title>
    <url>%2F2018%2F11%2F02%2FAndroid-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C-Cursor%2F</url>
    <content type="text"><![CDATA[参考文档： Android 数据库SQLite Cursor数据遍历读取 Android Cursor的正确遍历方法 Android sqlite cursor的遍历Android cursor遍历数据 Android笔记——关于Cursor类的介绍Android应用开发—关于SQL中通过cursor获取指定id的内容 单独谈谈 Android Cursor 的使用细节]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: WindowManager]]></title>
    <url>%2F2018%2F11%2F01%2FAndroid-WindowManager%2F</url>
    <content type="text"><![CDATA[参考文档 android之WindowManager学习 WindowManager和WindowManager.LayoutParams的使用以及实现悬浮窗口的方法]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: Service的线程问题]]></title>
    <url>%2F2018%2F11%2F01%2FAndroid-Service%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[参考文档 Android 你不知道的Service（服务） &amp; Thread（线程）]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: AlarmManager]]></title>
    <url>%2F2018%2F11%2F01%2FAndroid-AlarmManager%2F</url>
    <content type="text"><![CDATA[参考文档 关于使用 AlarmManager 的注意事项]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 定时器]]></title>
    <url>%2F2018%2F11%2F01%2FAndroid-%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[参考文档 Timer和TimerTask定时器使用]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 日期的格式化]]></title>
    <url>%2F2018%2F11%2F01%2FAndroid-%E6%97%A5%E6%9C%9F%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[参考文档 android格式化日期与时间戳学习]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: SystemProperties设置/取得系统属性]]></title>
    <url>%2F2018%2F11%2F01%2FAndroid-SystemProperties%E8%AE%BE%E7%BD%AE-%E5%8F%96%E5%BE%97%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[参考文档 Android SystemProperties设置/取得系统属性的用法总结]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: Cursor]]></title>
    <url>%2F2018%2F11%2F01%2FAndroid-Cursor%2F</url>
    <content type="text"><![CDATA[参考文档 Android数据库操作—-Cursor]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 自定义 AlertDialog]]></title>
    <url>%2F2018%2F10%2F31%2FAndroid-%E8%87%AA%E5%AE%9A%E4%B9%89-AlertDialog%2F</url>
    <content type="text"><![CDATA[参考文档： AlertDialog/AlertDialog.builder 以及 自定义AlertDialog方法]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 倒计时的实现]]></title>
    <url>%2F2018%2F10%2F31%2FAndroid-%E5%80%92%E8%AE%A1%E6%97%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[参考文档： Android 倒计时的五种实现方式]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: getCahceDir() & getFilesDir()]]></title>
    <url>%2F2018%2F10%2F30%2FAndroid-getCahceDir-getFilesDir%2F</url>
    <content type="text"><![CDATA[1. getCacheDir() 一般是Context.getCacheDir(), 会返回当前应用的缓存文件夹，路径为 data/data/project-name/cache 2. getFilesDir() 一般是Context.getFilesDir(), 会返回当前应用的数据存储文件夹，路径为 data/data/project-name/files ↑↑↑ 以上两个方法返回的是文件夹路径，文件夹！！ ==ATTENSION== 对文件的读写要另开一个线程来写。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java: File类中的list()和listFiles()]]></title>
    <url>%2F2018%2F10%2F27%2FJava-File%E7%B1%BB%E4%B8%AD%E7%9A%84list-%E5%92%8ClistFiles%2F</url>
    <content type="text"><![CDATA[参考文档： File类中的list()和listFiles()方法 list()方法是返回某个目录下的所有文件和目录的文件名，返回的是String数组 istFiles()方法是返回某个目录下所有文件和目录的绝对路径，返回的是File数组]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: handler消息处理]]></title>
    <url>%2F2018%2F10%2F26%2FAndroid-handler%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考文档： 【Android消息处理机制】Handler中sendEmptyMessage与sendMessage的区别和sendMessageAtTime()与sendEmptyMessageDelay()区别]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANdroid: DispalyMetrics]]></title>
    <url>%2F2018%2F10%2F26%2FANdroid-DispalyMetrics%2F</url>
    <content type="text"><![CDATA[参考文档： Android获取屏幕分辨率及DisplayMetrics简介]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: handler内存泄漏问题]]></title>
    <url>%2F2018%2F10%2F26%2FAndroid-handler%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[参考文档： 安卓Handler当做内部类，导致内存泄露的问题 Handler造成Activity泄漏，用弱引用真的有用么?]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 关于时间的广播]]></title>
    <url>%2F2018%2F10%2F25%2FAndroid-%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[参考文档： 安卓时间广播]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 拓展设备广播]]></title>
    <url>%2F2018%2F10%2F24%2FAndroid-%E6%8B%93%E5%B1%95%E8%AE%BE%E5%A4%87%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[参考文档： Sdcard插拔、状态广播监听，Android文件系统，Android存储器相关知识总结 此次用到三个： 1intentFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 蓝牙]]></title>
    <url>%2F2018%2F10%2F24%2FAndroid-%E8%93%9D%E7%89%99%2F</url>
    <content type="text"><![CDATA[参考文档：蓝牙 官方文档说得很清楚啊。。。 注意： 1. 被配对和被连接的区别 2. startDiscovery() 为异步进程，并且会立即返回一个布尔值，表示是否已成功启动发现操作，一个流程为12s。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常-今天又学习了什么呢]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%97%A5%E5%B8%B8-%E4%BB%8A%E5%A4%A9%E5%8F%88%E5%AD%A6%E4%B9%A0%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%2F</url>
    <content type="text"><![CDATA[Broadcast Thread Service Handler AsyncTask ServiceIntent StateMachine 是什么]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android: 日常新增不懂名词]]></title>
    <url>%2F2018%2F10%2F18%2FAndroid-%E6%97%A5%E5%B8%B8%E6%96%B0%E5%A2%9E%E4%B8%8D%E6%87%82%E5%90%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[set&lt;&gt;: 参考链接： java中Set的用法]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android: 如何在Service里使用Context]]></title>
    <url>%2F2018%2F10%2F17%2FAndroid-%E5%A6%82%E4%BD%95%E5%9C%A8Service%E9%87%8C%E4%BD%BF%E7%94%A8Context%2F</url>
    <content type="text"><![CDATA[参考文档： 在Service中获得Context 使用方法： Service 本身就是 Context 的实现，所以只需要调用 this，示例代码如下： 123456/*** EthernetManager ethernetManager = (EthernetManager) context.getSystemService( Context.ETHERNET_SERVICE);*/EthernetManager ethernetManager = (EthernetManager) this.getSystemService( Context.ETHERNET_SERVICE); 1. 在AsyncTask中使用context传入Context，在doInBackground(Context... params){}中调用就好啦。 Android 多线程之IntentService 完全详解参考文档： https://blog.csdn.net/javazejian/article/details/52426425]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 父控件拦截子控件点击事件问题]]></title>
    <url>%2F2018%2F10%2F12%2FAndroid-%E7%88%B6%E6%8E%A7%E4%BB%B6%E6%8B%A6%E6%88%AA%E5%AD%90%E6%8E%A7%E4%BB%B6%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 编译报错汇总]]></title>
    <url>%2F2018%2F10%2F10%2FAndroid-Studio-%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1. 错误：对findViewById的引用不明确情景：在导入一个第三方 jar 包后，编译出现如下错误 1234错误: 对findViewById的引用不明确 Activity 中的方法 findViewById(int) 和 AppCompatActivity 中的方法 &lt;T&gt;findViewById(int) 都匹配 其中, T是类型变量: T扩展已在方法 &lt;T&gt;findViewById(int)中声明的View 原因： jar 包和工程使用的 sdk 版本不同 解决办法：在 module 下的 build.gradle 文件里添加如下代码 1234567891011configurations.all &#123; resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt; def requested = details.requested if (requested.group == 'com.android.support') &#123; if (!requested.name.startsWith("multidex")) &#123; //这里指定需要统一的依赖版本,这里统一为26.0.0-alpha1 details.useVersion '26.0.0-alpha1' &#125; &#125; &#125;&#125; 然后 sync 一下就行了。 2. W/System.err: at android.os.Parcel.readException(Parcel.java:1472)参考文档： 关于使用AIDL出现空指针的解决办法 情景： 在使用PppoeManager.setMode() 和 PppoeManager.connect()过程中，报如下错误 123456W/System.err: at android.os.Parcel.readException(Parcel.java:1472) at android.os.Parcel.readException(Parcel.java:1426) at android.net.pppoe.IPppoeManager$Stub$Proxy.setPppoeMode(IPppoeManager.java:318) at android.net.pppoe.PppoeManager.setPppoeMode(PppoeManager.java:115) at com.example.eileen.boxsetting.PppoeConnectTask.doInBackground(PppoeConnectTask.java:50) at com.example.eileen.boxsetting.PppoeConnectTask.doInBackground(PppoeConnectTask.java:13) 原因： 简单说来，就是在远程方法没有执行完成的情况下，transact()执行完成了，然后抛出了一个空指针。 解决办法： 我没有解决办法，啊！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test picture]]></title>
    <url>%2F2018%2F10%2F09%2Ftest-picture%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Android: AS 如何导入 jar 包]]></title>
    <url>%2F2018%2F09%2F29%2FAndroid-AS-%E5%A6%82%E4%BD%95%E5%AF%BC%E5%85%A5-jar-%E5%8C%85%2F</url>
    <content type="text"><![CDATA[参考文档： Android Studio导入和删除jar包 这是一个神奇的网站 1. 具体步骤 复制 jar 包到 【项目-&gt;app-&gt;libs】路径下，如果没有 libs 文件夹，自己新建一个就行。 右键 jar 包，选择 【add as library】，等待项目编译完成。 到 build.gradle 文件中查看 dependecies 下是否有加入导入的 jar 包，比如我的是： 没有就自己手动添加试试？ 到此导入 jar 包的步骤就完成了。 2. 异常处理不过通常会报以下错误：这个错误的主要原因 &amp; 分类解决办法戳链接看 配置方法数超过64K的应用， 1234Cannot fit requested classes in a single dex file. Try supplying a main-dex list.# methods: 82121 &gt; 65536Message&#123;kind=ERROR, text=Cannot fit requested classes in a single dex file. Try supplying a main-dex list.# methods: 82121 &gt; 65536, sources=[Unknown source file], tool name=Optional.of(D8)&#125; 解决办法： 在app build.gradle 文件中，dependencies下添加 1implementation 'com.android.support:multidex:1.0.3' 然后在这个文件中找到 defaultConfig, 在里面添加 1multiDexEnabled true]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 关于使用 Dialog样式的Activity闪退问题]]></title>
    <url>%2F2018%2F09%2F27%2FAndroid-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8-Dialog%E6%A0%B7%E5%BC%8F%E7%9A%84Activity%E9%97%AA%E9%80%80%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述： 在尝试使用 Dialog 风格 Activity 的时候，参考了一篇文章【参考链接】，但是运行时却发生闪退情况。 解决办法： 自己琢磨了一下，发现在使用 Dialog 风格 Activity 时，activity 应该 extends Activity, 而我代码写的是extends AppCompatActivity。原理尚不清楚，坑先挖在这了，等着填。 原来 activity 部分代码： 1234567public class DevDialogActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dev_dialog); &#125;&#125; 修改后 activity 部分代码： 1234567public class DevDialogActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_dev_dialog); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 获取系统时间并格式化显示]]></title>
    <url>%2F2018%2F09%2F27%2FAndroid-%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 如何让 ViewGroup 监听按键事件]]></title>
    <url>%2F2018%2F09%2F25%2FAndroid-%E5%A6%82%E4%BD%95%E8%AE%A9-ViewGroup-%E7%9B%91%E5%90%AC%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[待解决]Android: 关于 Fragment 调用 Fragment 时闪退的问题]]></title>
    <url>%2F2018%2F09%2F21%2FAndroid-%E5%85%B3%E4%BA%8E-Fragment-%E8%B0%83%E7%94%A8-Fragment-%E6%97%B6%E9%97%AA%E9%80%80%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[​ 问题描述： 在使用 Fragment 调用新的 Fragment 时，遇到程序闪退的情况。代码如下： 1dddd 解决方法： 貌似是]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 关于Fragment初始化闪退问题]]></title>
    <url>%2F2018%2F09%2F19%2FAndroid-%E5%85%B3%E4%BA%8EFragment%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AA%E9%80%80%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[参考文档： Android中如何在Fragment中添加点击事件切换新的Fragment 问题描述： 在 Fragment 中，有一些控件（TextView）是需要动态赋值的，然后天真的我直接在 onCreateView中根据用setText()方法 来做。结果就是——闪退。最后发现取到的 TextView 是 null 。 解决办法： 其实有一个方法，是onActivityCreated() ，在里面为控件赋值就 OK 的。该方法是等布局加载完成之后，才能通过 ID 取到 Fragment 中的控件。相当于：我在水果店里买东西，伸手想从一个果篮里拿水果出来，但是发现篮子里什么都没有，等店员往里面放了商品之后，我才能在篮子里挑选自己想要的东西。 具体代码如下： 12345678910111213141516public class FragmentMyInfo extends Fragment&#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)&#123; View view = inflater.inflate(R.layout.fragment_my_info, container,false); return view; &#125; public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); //这里写要动态赋值的代码 TextView devType = (TextView) getActivity().findViewById(R.id.dev_type); Log.d(TAG, &quot;onCreateView: &quot; + devType); devType.setText(R.string.dev_type); &#125;&#125; 多说一句： title 没有取好，但暂时还不知道怎么用精准且简洁的语言来描述这个问题；第一次尝试用比喻来讲一个问题，也不知道比喻使用恰不恰当。之后想到了更好的都会改。 菜鸟发出一声凄厉的尖叫]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: Fragment详解]]></title>
    <url>%2F2018%2F09%2F18%2FAndroid-Fragment%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[背景介绍： ​ 最近有个练习，考虑用 Fragment 来做，所以研究了一下。 参考文档： Android基础：Fragment，看这篇就够了 利用Bundle完成Activity向Fragment传值 Android中如何在Fragment中添加点击事件切换新的Fragment Android 文本动态处理方法，TextView动态赋值 可复写的方法： onCreateView()，返回 Fragment 的 UI 布局 Tips: 如果在创建 Fragment 时，需要传入参数，建议使用 setArguments()]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: 控件篇（一）]]></title>
    <url>%2F2018%2F09%2F18%2FAndroid-%E6%8E%A7%E4%BB%B6%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景介绍： 本文仅记录学习 Android 过程中遇到的各类控件，大概以后会分类总结一下吧，现在只是无脑填充。 1. 显示时间的容器：TextClock参考文档： Android 实时显示时间 问题描述： 开发过程中需要一个能够显示时间的 TextView，时间分为 24 小时和 12 小时两种格式。类似于：[下午11:08]、[23:08]。 解决办法： Google 一下，你就知道。哈哈哈哈开个玩笑，不过确实是 Google 出来的。使用 TextClock 控件，注意：听说这控件 ==API &gt;= 17== 才可用，代码如下： 123456&lt;TextClock style="@style/LayoutContentStyle" android:layout_weight="5" android:gravity="center" android:format12Hour="aa hh:mm" android:format24Hour="hh:mm"/&gt; 其中 style 是用的自己写的一个样式，我们只用关注 format12Hour &amp; format24Hour两个属性即可。 format12Hour，表示12小时制的显示格式，”aa” 表示显示上午/下午，其它大家读懂。 format24Hour，表示24小时制的显示格式。 如果需要显示日期，用 &quot;yyyy/MM/dd hh:mm:ss&quot; 即可。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git: HttpRequestException encountered]]></title>
    <url>%2F2018%2F09%2F18%2FGit-HttpRequestException-encountered%2F</url>
    <content type="text"><![CDATA[问题描述： 之前 git 用得好好的，一个周末回来，git push 的时候就报HttpRequestException encountered.这种错，网上查了 下解决办法 ↓ 解决办法： 点击下载最新的 GCM 下载后安装好就行了…这个问题好像只有 windows 会出现，原理的话，可以看看参考文章。 参考： [git push fatal: HttpRequestException encountered] 2. git pull 报! [rejected] master -&gt; master (non-fast-forward) 错误解决办法： git pull -f]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android: TextView 样式问题]]></title>
    <url>%2F2018%2F09%2F17%2FAndroid-TextView-%E6%A0%B7%E5%BC%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景介绍本文单纯记录学习 Android 路上遇到的样式问题。 1. 为 TextView 文字设置两个对齐方向解决办法： Android 中的 gravity 属性阔以这样写： android:gravity=&quot;center_vertical|right&quot; ，表示垂直居中，水平靠右。如果需要其它对其方向，可以参考。 2. EditView 去掉边框（下划线）解决办法： 属性这样写：android:background=&quot;@null&quot; 。 3. 居中问题需要控件中的内容居中： 使用 android:gravity 属性 需要控件在父布局中居中： 使用 android:layout_gravity 属性 4. 边距问题关于边距，有两个属性可用：margin 和 padding margin: 指控件与控件的距离。 padding: 指控件的内边距，肚子里面装的文本之类的东西与边框的距离。 ==如果仍然迷惑，可以打开 Chrome，Windows 下按 F12 进入调试模式，看看标准的盒子模型== 当然直接用搜索引擎搜标准盒子模型也可以 ↑↑↑ 5. 关于 visibility 属性的使用控件的 visibility 属性决定该控件是否可见，当值为 android:visibility=&quot;invisible&quot;时，控件不可见，==但控件仍然在页面上占据位置==。 代码中动态设置控件是否可见： 使用view.setVisibility(int)方法，该方法接收一个 int 值，有两个可选项：View.VISIBLE &amp; View.INVISIBLE. 也就是说，如果需要设置控件可见，可以这样写 12TextView tv = (TextView) findViewById(R.id.xxx);tv.setVisibility(View.VISIBLE); //不可见同理 EditText.setSelectAllOnFocus(true); ​]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
